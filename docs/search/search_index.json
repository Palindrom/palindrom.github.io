{
    "docs": [
        {
            "location": "/",
            "text": "Intro\n\n\n\n  \n\n\n\n\n\nBinds client side view models to server side view models using JSON-Patch and HTTP PATCH/WebSocket.",
            "title": "Intro"
        },
        {
            "location": "/#intro",
            "text": "",
            "title": "Intro"
        },
        {
            "location": "/#binds-client-side-view-models-to-server-side-view-models-using-json-patch-and-http-patchwebsocket",
            "text": "",
            "title": "Binds client side view models to server side view models using JSON-Patch and HTTP PATCH/WebSocket."
        },
        {
            "location": "/01-_Installation/",
            "text": "Installation\n\n\nYou can install using \nbower\n and \nNPM\n:\n\n\nBower:\n\n\nbower install Palindrom --save\n\n\n\n\nThen add source to your HTML\n\n\n<!-- include Palindrom bundle -->\n<script src=\"bower_components/Palindrom/dist/palindrom.js\"></script>\n\n\n\n\nSee \nDependencies section\n for more details.\n\n\nNPM:\n\n\nnpm install palindrom --save\n\n\n\n\nThen you can require it CommonJS or ES6/TS style:\n\n\n//CommonJS\nvar Palindrom = require('palindrom');\n\n// ES6/TS\nimport Palindrom from 'palindrom'\n\n\n\n\nOr just download it manually from \ngithub\n.",
            "title": "Installation"
        },
        {
            "location": "/01-_Installation/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/01-_Installation/#you-can-install-using-bower-and-npm",
            "text": "",
            "title": "You can install using bower and NPM:"
        },
        {
            "location": "/01-_Installation/#bower",
            "text": "bower install Palindrom --save  Then add source to your HTML  <!-- include Palindrom bundle -->\n<script src=\"bower_components/Palindrom/dist/palindrom.js\"></script>  See  Dependencies section  for more details.",
            "title": "Bower:"
        },
        {
            "location": "/01-_Installation/#npm",
            "text": "npm install palindrom --save  Then you can require it CommonJS or ES6/TS style:  //CommonJS\nvar Palindrom = require('palindrom');\n\n// ES6/TS\nimport Palindrom from 'palindrom'",
            "title": "NPM:"
        },
        {
            "location": "/01-_Installation/#or-just-download-it-manually-from-github",
            "text": "",
            "title": "Or just download it manually from github."
        },
        {
            "location": "/02-_Palindrom/",
            "text": "Palindrom\n\n\n\n\nPalindrom is a library for two-way data binding between local and remote JSON models. It uses JSON-Patch for data updates and Operational Transformation for versioning and data consistency. It operates via HTTP or WebSocket or both.\n\n\n\n\nUsage\n\n\nAfter DOM is ready, initialize with the constructor:\n\n\n/**\n * Defines a connection to a remote PATCH server, gives an object that is persistent between browser and server\n */\nvar palindrom = new Palindrom({remoteUrl: window.location.href});\n\n// ..\n// use palindrom.obj\npalindrom.obj.someProperty = \"new value\";\n\n\n\n\n\n\nNote 1: Please make sure you pass the correct PATCH server URL.\n\n\nNote 2: \npalindrom.obj\n is only available after \noptions.onStateReset\n is called.\n\n\n\n\nDemo\n\n\n\n\nExample with Polymer's Template Binding and Web Components\n\n\nExample with Vue\n\n\nExample with React\n\n\n\n\nOptions (\nPalindrom()\n constructor parameters)\n\n\nAll the parameters are optional.\n\n\nvar palindrom = new Palindrom({attribute: value});\n\n\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nremoteUrl\n\n\nString\n\n\nRequired\n\n\nPATCH server URL\n\n\n\n\n\n\nonStateReset\n\n\nFunction\n\n\n\n\nCalled after initial state object is received from the server (NOT necessarily after WS connection was established), \nit can be called again if the state was reset by a root-replacing patch\n.\n\n\n\n\n\n\nuseWebSocket\n\n\nBoolean\n\n\nfalse\n\n\nSet to \ntrue\n to enable WebSocket support\n\n\n\n\n\n\ndebug\n\n\nBoolean\n\n\ntrue\n\n\nToggle debugging mode\n\n\n\n\n\n\nfilterLocalChange\n\n\nFunction\n\n\n\n\nA function that is called with every local change and allows you to filter (ignore) some changes. See \nFiltering Patches\n section.\n\n\n\n\n\n\nonLocalChange\n\n\nFunction\n\n\n\n\nHelper callback triggered each time a change is observed locally\n\n\n\n\n\n\nonRemoteChange\n\n\nFunction\n\n\n\n\nHelper callback triggered each time a change is received from the server and applied.\n\n\n\n\n\n\nonPatchReceived\n\n\nFunction\n\n\n\n\nHelper callback triggered each time a JSON-patch is received, accepts three parameters: (\nString\n \ndata\n, \nString\n \nurl\n, \nString\n \nmethod\n)\n\n\n\n\n\n\nonPatchSent\n\n\nFunction\n\n\n\n\nHelper callback triggered each time a JSON-patch is sent, accepts two parameters: (\nString\n \ndata\n, \nString\n \nurl\n, \nString\n \nmethod\n)\n\n\n\n\n\n\nonSocketStateChanged\n\n\nFunction\n\n\n\n\nHelper callback triggered when socket state changes, accepts next parameters: (\nint\n \nstate\n, \nString\n \nurl\n, \nString\n \ndata\n, \nint\n \ncode\n, \nString\n \nreason\n)\n\n\n\n\n\n\nonError\n\n\nFunction\n\n\n\n\nHelper callback triggered when a generic error occurs. Accepts one parameter: (\nPalindromError\n \nerror\n) \nPalindromError\n has the following properties: (\nString\n \nmessage\n) it extends ES6 Error, it has the stack trace with all the information \nError\n class offers.\n\n\n\n\n\n\nonConnectionError\n\n\nFunction\n\n\n\n\nHelper callback triggered when socket connection closed, socket connection failed to establish, http requiest failed. Accepts one parameter: (\nPalindromConnectionError\n \nerror\n). \nPalindromConnectionError\n has the following properties: (\nString\n \nmessage\n, \nString\n \nside <Server\\|Client>\n, \nString\n \nurl\n, \nString\n \nconnectionType\n). It extends ES6 Error class, it has the stack trace with all the information \nError\n class offers.\n\n\n\n\n\n\nonIncomingPatchValidationError\n\n\nFunction\n\n\n\n\nHelper callback triggered when a wrong patch is received. It accepts one \nError\n parameter.\n\n\n\n\n\n\nonOutgoingPatchValidationError\n\n\nFunction\n\n\n\n\nHelper callback triggered when a wrong patch is locally issued. It accepts one \nError\n parameter.\n\n\n\n\n\n\nlocalVersionPath\n\n\nJSONPointer\n\n\ndisabled\n\n\nlocal version path, set it to enable Versioned JSON Patch communication\n\n\n\n\n\n\nremoteVersionPath\n\n\nJSONPointer\n\n\ndisabled\n\n\nremote version path, set it (and \nlocalVersionPath\n) to enable Versioned JSON Patch communication\n\n\n\n\n\n\not\n\n\nBoolean\n\n\nfalse\n\n\ntrue\n to enable OT (requires \nlocalVersionPath\n and \nremoteVersionPath\n)\n\n\n\n\n\n\npurity\n\n\nBoolean\n\n\nfalse\n\n\ntrue\n to enable purist mode of OT\n\n\n\n\n\n\npingIntervalS\n\n\nNumber\n\n\n0\n\n\nPalindrom will generate heartbeats every \npingIntervalS\n seconds if no activity is detected. \n0\n - disable heartbeat\n\n\n\n\n\n\nretransmissionThreshold\n\n\nNumber\n\n\n3\n\n\nAfter server reports this number of messages missing, we start retransmission\n\n\n\n\n\n\nonReconnectionCountdown\n\n\nFunction\n\n\n\n\nTriggered when palindrom detected connection problem and reconnection is scheduled. Accepts number of milliseconds to scheduled reconnection. Called every second until countdown reaches 0 (inclusive)\n\n\n\n\n\n\nonReconnectionEnd\n\n\nFunction\n\n\n\n\nTriggered when palindrom successfully reconnected\n\n\n\n\n\n\njsonpatch\n\n\nObject\n\n\nwindow.jsonpatch\n\n\nThe provider object for jsonpatch \napply\n and  \nvalidate\n. By default it uses Starcounter-Jack/JSON-Patch library.\n\n\n\n\n\n\n\n\nmost of the properties are accessible also in runtime:\n\n\nProperties\n\n\npalindrom.property\n\n\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nremoteUrl\n\n\nString\n\n\nRequired\n\n\nSee above\n\n\n\n\n\n\nobj [readonly]\n\n\nObject\n\n\n{}\n\n\nYour initial state object, \nplease read notes below\n.\n\n\n\n\n\n\nuseWebSocket\n\n\nBoolean\n\n\nfalse\n\n\nSee above\n\n\n\n\n\n\ndebug\n\n\nBoolean\n\n\ntrue\n\n\nSee above\n\n\n\n\n\n\nonRemoteChange\n\n\nFunction\n\n\n\n\nSee above\n\n\n\n\n\n\nonPatchReceived\n\n\nFunction\n\n\n\n\nSee above\n\n\n\n\n\n\nonSocketStateChanged\n\n\nFunction\n\n\n\n\nSee above\n\n\n\n\n\n\nonPatchSent\n\n\nFunction\n\n\n\n\nSee above\n\n\n\n\n\n\nonConnectionError\n\n\nFunction\n\n\n\n\nSee above\n\n\n\n\n\n\nonIncomingPatchValidationError\n\n\nFunction\n\n\n\n\nSee above\n\n\n\n\n\n\nonOutgoingPatchValidationError\n\n\nFunction\n\n\n\n\nSee above\n\n\n\n\n\n\nversion\n\n\nString \nsemver\n\n\n\n\nContains current Palindrom version, available statically too (i.e: \nPalindrom.version\n)\n\n\n\n\n\n\n\n\n\n\n Note 1: \npalindrom.obj\n becomes only available after \noptions.onStateReset\n is called.\n\n\n Note 2: \npalindrom.obj\n is a constant (as in \nconst\n) property, you can modify its properties but you can't assign it again or \ndelete\n it. \npalindrom.obj = {}\n would throw an error.\n\n\n\n\nBinding object once is ready (\nonStateReset\n)\n\n\nTo bind object where you need once it will be fetched from remote you can use define \nonStateReset\n in constructor:\n\n\nvar palindrom = new Palindrom({remoteUrl: url, onStateReset: function (obj) {\n  document.getElementById('test').model = obj;\n}});\n\n\n\n\nSending client changes to remote\n\n\nPalindrom detects changes to the observed object synchronously. So after\n\n\npalindrom.obj.some=\"change\";\n\n\n\n\nThe JSON Patch request will be send to the remote.\n\n\nTwo-way data binding frameworks\n\n\nPalindrom works superbly with frameworks that allow for two-way data binding, such as Polymer, React, Vue and Angular. These frameworks have the ability to bind an \n<input>\n element to a JavaScript data model in a way that the object updates after each keystroke. In consequence, Palindrom sends a patch the server after each keystroke.\n\n\nIf you want to opt-out from such behavior, you need to force your framework to update the data model after the element is unfocused (\nblur\n event). Depending on the framework:\n\n\n\n\nIn Polymer 0.5 it is only possible with a Custom Element that extends the native \n<input>\n, similarly but not exactly how \ncore-input\n is dome\n\n\nIn Polymer 0.9+, use built-in \n<input value=\"{{bindValue::blur}}\">\n\n\nIn Angular 1.3+, use built-in \n<input type=\"text\" ng-model=\"name\" ng-model-options=\"{updateOn: 'blur'}\" />\n\n\n\n\nUpgrading to WebSocket (\nuseWebSocket\n)\n\n\nYou can upgrade the communication protocol to use WebSocket by setting \nuseWebSocket: true\n option in Palindrom constructor or you can switch it at any moment by \npalindrom.useWebSocket = true\n.\n\n\nWebSocket is a replacement for requests that would be sent using \nHTTP PATCH\n otherwise. The requests sent over \nHTTP GET\n (such as link clicks) are not affected.\n\n\n:bulb: Note that this is an experimental implementation in which the WebSocket upgrade request URL taken from \nX-Location\n header of your first AJAX call response.\n\n\nSample:\n\n\n// enable it in constructor\nvar palindrom = new Palindrom({remoteUrl: url, useWebSocket: true});\n// change it later via property\npalindrom.useWebSocket = false;\n\n\n\n\nHeartbeat and reconnection\n\n\nPalindrom will try to detect connection problems and then reconnect to server. If \npingIntervalS\n is set it determines maximal time without network activity. When this time passes and no activity has been detected\nPalindrom will issue a heartbeat patch (an empty patch, consisting only of version operations).\n\n\nWhen connection problem is detected (e.g. there was no response to heartbeat or websocket has been closed) palindrom will schedule reconnection and trigger \nonReconnectionCountdown\n callback with number of milliseconds\nto scheduled reconnection as argument, it will then trigger it every second. When countdown reaches 0 (callback is still called then) palindrom will try to reconnect (using \n/reconnect\n endpoint) to server. If this reconnection\nfails then new reconnection will be scheduled for twice as many seconds (i.e. first it will occur after a seconds, then two seconds, then four, etc.). If reconnection succeeds, \nonReconnectionEnd\n callback will be triggered\nand normal operations will continue.\n\n\nFor successful reconnection, palindrom sends a list of pending patches (those sent, but unconfirmed by server) to \n/reconnect\n endpoint and accepts a new state (along with version numbers) as a response. It then resets\nto this new state and resumes its operations.",
            "title": "Palindrom"
        },
        {
            "location": "/02-_Palindrom/#palindrom",
            "text": "Palindrom is a library for two-way data binding between local and remote JSON models. It uses JSON-Patch for data updates and Operational Transformation for versioning and data consistency. It operates via HTTP or WebSocket or both.",
            "title": "Palindrom"
        },
        {
            "location": "/02-_Palindrom/#usage",
            "text": "After DOM is ready, initialize with the constructor:  /**\n * Defines a connection to a remote PATCH server, gives an object that is persistent between browser and server\n */\nvar palindrom = new Palindrom({remoteUrl: window.location.href});\n\n// ..\n// use palindrom.obj\npalindrom.obj.someProperty = \"new value\";   Note 1: Please make sure you pass the correct PATCH server URL.  Note 2:  palindrom.obj  is only available after  options.onStateReset  is called.",
            "title": "Usage"
        },
        {
            "location": "/02-_Palindrom/#demo",
            "text": "Example with Polymer's Template Binding and Web Components  Example with Vue  Example with React",
            "title": "Demo"
        },
        {
            "location": "/02-_Palindrom/#options-palindrom-constructor-parameters",
            "text": "All the parameters are optional.  var palindrom = new Palindrom({attribute: value});     Attribute  Type  Default  Description      remoteUrl  String  Required  PATCH server URL    onStateReset  Function   Called after initial state object is received from the server (NOT necessarily after WS connection was established),  it can be called again if the state was reset by a root-replacing patch .    useWebSocket  Boolean  false  Set to  true  to enable WebSocket support    debug  Boolean  true  Toggle debugging mode    filterLocalChange  Function   A function that is called with every local change and allows you to filter (ignore) some changes. See  Filtering Patches  section.    onLocalChange  Function   Helper callback triggered each time a change is observed locally    onRemoteChange  Function   Helper callback triggered each time a change is received from the server and applied.    onPatchReceived  Function   Helper callback triggered each time a JSON-patch is received, accepts three parameters: ( String   data ,  String   url ,  String   method )    onPatchSent  Function   Helper callback triggered each time a JSON-patch is sent, accepts two parameters: ( String   data ,  String   url ,  String   method )    onSocketStateChanged  Function   Helper callback triggered when socket state changes, accepts next parameters: ( int   state ,  String   url ,  String   data ,  int   code ,  String   reason )    onError  Function   Helper callback triggered when a generic error occurs. Accepts one parameter: ( PalindromError   error )  PalindromError  has the following properties: ( String   message ) it extends ES6 Error, it has the stack trace with all the information  Error  class offers.    onConnectionError  Function   Helper callback triggered when socket connection closed, socket connection failed to establish, http requiest failed. Accepts one parameter: ( PalindromConnectionError   error ).  PalindromConnectionError  has the following properties: ( String   message ,  String   side <Server\\|Client> ,  String   url ,  String   connectionType ). It extends ES6 Error class, it has the stack trace with all the information  Error  class offers.    onIncomingPatchValidationError  Function   Helper callback triggered when a wrong patch is received. It accepts one  Error  parameter.    onOutgoingPatchValidationError  Function   Helper callback triggered when a wrong patch is locally issued. It accepts one  Error  parameter.    localVersionPath  JSONPointer  disabled  local version path, set it to enable Versioned JSON Patch communication    remoteVersionPath  JSONPointer  disabled  remote version path, set it (and  localVersionPath ) to enable Versioned JSON Patch communication    ot  Boolean  false  true  to enable OT (requires  localVersionPath  and  remoteVersionPath )    purity  Boolean  false  true  to enable purist mode of OT    pingIntervalS  Number  0  Palindrom will generate heartbeats every  pingIntervalS  seconds if no activity is detected.  0  - disable heartbeat    retransmissionThreshold  Number  3  After server reports this number of messages missing, we start retransmission    onReconnectionCountdown  Function   Triggered when palindrom detected connection problem and reconnection is scheduled. Accepts number of milliseconds to scheduled reconnection. Called every second until countdown reaches 0 (inclusive)    onReconnectionEnd  Function   Triggered when palindrom successfully reconnected    jsonpatch  Object  window.jsonpatch  The provider object for jsonpatch  apply  and   validate . By default it uses Starcounter-Jack/JSON-Patch library.     most of the properties are accessible also in runtime:",
            "title": "Options (Palindrom() constructor parameters)"
        },
        {
            "location": "/02-_Palindrom/#properties",
            "text": "palindrom.property     Attribute  Type  Default  Description      remoteUrl  String  Required  See above    obj [readonly]  Object  {}  Your initial state object,  please read notes below .    useWebSocket  Boolean  false  See above    debug  Boolean  true  See above    onRemoteChange  Function   See above    onPatchReceived  Function   See above    onSocketStateChanged  Function   See above    onPatchSent  Function   See above    onConnectionError  Function   See above    onIncomingPatchValidationError  Function   See above    onOutgoingPatchValidationError  Function   See above    version  String  semver   Contains current Palindrom version, available statically too (i.e:  Palindrom.version )       Note 1:  palindrom.obj  becomes only available after  options.onStateReset  is called.   Note 2:  palindrom.obj  is a constant (as in  const ) property, you can modify its properties but you can't assign it again or  delete  it.  palindrom.obj = {}  would throw an error.",
            "title": "Properties"
        },
        {
            "location": "/02-_Palindrom/#binding-object-once-is-ready-onstatereset",
            "text": "To bind object where you need once it will be fetched from remote you can use define  onStateReset  in constructor:  var palindrom = new Palindrom({remoteUrl: url, onStateReset: function (obj) {\n  document.getElementById('test').model = obj;\n}});",
            "title": "Binding object once is ready (onStateReset)"
        },
        {
            "location": "/02-_Palindrom/#sending-client-changes-to-remote",
            "text": "Palindrom detects changes to the observed object synchronously. So after  palindrom.obj.some=\"change\";  The JSON Patch request will be send to the remote.",
            "title": "Sending client changes to remote"
        },
        {
            "location": "/02-_Palindrom/#two-way-data-binding-frameworks",
            "text": "Palindrom works superbly with frameworks that allow for two-way data binding, such as Polymer, React, Vue and Angular. These frameworks have the ability to bind an  <input>  element to a JavaScript data model in a way that the object updates after each keystroke. In consequence, Palindrom sends a patch the server after each keystroke.  If you want to opt-out from such behavior, you need to force your framework to update the data model after the element is unfocused ( blur  event). Depending on the framework:   In Polymer 0.5 it is only possible with a Custom Element that extends the native  <input> , similarly but not exactly how  core-input  is dome  In Polymer 0.9+, use built-in  <input value=\"{{bindValue::blur}}\">  In Angular 1.3+, use built-in  <input type=\"text\" ng-model=\"name\" ng-model-options=\"{updateOn: 'blur'}\" />",
            "title": "Two-way data binding frameworks"
        },
        {
            "location": "/02-_Palindrom/#upgrading-to-websocket-usewebsocket",
            "text": "You can upgrade the communication protocol to use WebSocket by setting  useWebSocket: true  option in Palindrom constructor or you can switch it at any moment by  palindrom.useWebSocket = true .  WebSocket is a replacement for requests that would be sent using  HTTP PATCH  otherwise. The requests sent over  HTTP GET  (such as link clicks) are not affected.  :bulb: Note that this is an experimental implementation in which the WebSocket upgrade request URL taken from  X-Location  header of your first AJAX call response.  Sample:  // enable it in constructor\nvar palindrom = new Palindrom({remoteUrl: url, useWebSocket: true});\n// change it later via property\npalindrom.useWebSocket = false;",
            "title": "Upgrading to WebSocket (useWebSocket)"
        },
        {
            "location": "/02-_Palindrom/#heartbeat-and-reconnection",
            "text": "Palindrom will try to detect connection problems and then reconnect to server. If  pingIntervalS  is set it determines maximal time without network activity. When this time passes and no activity has been detected\nPalindrom will issue a heartbeat patch (an empty patch, consisting only of version operations).  When connection problem is detected (e.g. there was no response to heartbeat or websocket has been closed) palindrom will schedule reconnection and trigger  onReconnectionCountdown  callback with number of milliseconds\nto scheduled reconnection as argument, it will then trigger it every second. When countdown reaches 0 (callback is still called then) palindrom will try to reconnect (using  /reconnect  endpoint) to server. If this reconnection\nfails then new reconnection will be scheduled for twice as many seconds (i.e. first it will occur after a seconds, then two seconds, then four, etc.). If reconnection succeeds,  onReconnectionEnd  callback will be triggered\nand normal operations will continue.  For successful reconnection, palindrom sends a list of pending patches (those sent, but unconfirmed by server) to  /reconnect  endpoint and accepts a new state (along with version numbers) as a response. It then resets\nto this new state and resumes its operations.",
            "title": "Heartbeat and reconnection"
        },
        {
            "location": "/03-_Filtering_and_ignoring_changes/",
            "text": "Filtering and ignoring changes\n\n\nPalindrom deeply observes changes made to the \npalindrom.obj\n object and converts them to patches. If you have a need to ignore some kind of changes, there are two ways to do it. Either make the changes in non-enumerable property or use a filtering function to ignore changes made in the enumerable properties.\n\n\n1. By defining non-enumerable properties \n(recommended)\n:\n\n\nPalindrom only generates patches for the enumerable properties of \npalindrom.obj\n and its subtrees. To create a part of the tree that is invisible for Palindrom's patch collection, define a non-enumerable property.\n\n\nAssuming your Palindrom instance is instantiated and your \npalindrom.obj\n is ready, you can create a non-enumerable object child in \npalindrom.obj\n and use it as a local non-observed store for your needs.\n\n\nExample:\n\n\nObject.defineProperty(palindrom.obj, \"myLocalNonSyncedObject\", {\n    enumerable: false,\n    value: {}\n});\n\n\n\n\nNow \npalindrom.obj.myLocalNonSyncedObject\n is an object this is not observed for patch generation. This is ideal for keeping client-side related information (eg: div height, or something like \nisModalWarningDisplayed = true\n).\n\n\nExample:\n\n\npalindrom.obj.myLocalNonSyncedObject.divHeight = 50;\n\n\n\n\n... does not generate a patch.\n\n\nNote:  In most cases, the added property is recommended to be an object.\n*\n\n\n*Note: You should not replace the value of the non-enumerable property after it has been defined. Otherwise Palindrom will still detect the change. If you want to modify the unobserved values, you should declare the non-enumerable property as an object and only modify its children.\n\n\n2. By extending \nPalindrom#filterLocalChange\n\n\nYou can discard a generated patch by extending \nPalindrom.filterLocalChange\n function. This function accepts a JSON Patch operation and either returns it or returns a falsy value. Returning a falsy value results in ignoring this operation.\n\n\nExample\n\n\nconst palindrom = new Palindrom({ remoteUrl: window.location.href });\n\nvar old = palindrom.filterLocalChange;\npalindrom.filterLocalChange = function(operation) {\n    operation = old.call(palindrom, operation); //make sure you don't overwrite other filters\n    if (operation && !operation.path.startsWith('$')) {\n        return operation;\n    }\n}\n// use palindrom.obj\npalindrom.obj.$someProperty = 'new value'; // this change will be ignored and will not reach the server\n\n\n\n\nYou can also pass \nfilterLocalChange\n to Palindrom constructor as in:\n\n\nconst palindrom = new Palindrom({ remoteUrl: window.location.href, filterLocalChange: op => !op.path.startsWith('$') && op });",
            "title": "Filtering and ignoring changes"
        },
        {
            "location": "/03-_Filtering_and_ignoring_changes/#filtering-and-ignoring-changes",
            "text": "Palindrom deeply observes changes made to the  palindrom.obj  object and converts them to patches. If you have a need to ignore some kind of changes, there are two ways to do it. Either make the changes in non-enumerable property or use a filtering function to ignore changes made in the enumerable properties.",
            "title": "Filtering and ignoring changes"
        },
        {
            "location": "/03-_Filtering_and_ignoring_changes/#1-by-defining-non-enumerable-properties-recommended",
            "text": "Palindrom only generates patches for the enumerable properties of  palindrom.obj  and its subtrees. To create a part of the tree that is invisible for Palindrom's patch collection, define a non-enumerable property.  Assuming your Palindrom instance is instantiated and your  palindrom.obj  is ready, you can create a non-enumerable object child in  palindrom.obj  and use it as a local non-observed store for your needs.",
            "title": "1. By defining non-enumerable properties (recommended):"
        },
        {
            "location": "/03-_Filtering_and_ignoring_changes/#example",
            "text": "Object.defineProperty(palindrom.obj, \"myLocalNonSyncedObject\", {\n    enumerable: false,\n    value: {}\n});  Now  palindrom.obj.myLocalNonSyncedObject  is an object this is not observed for patch generation. This is ideal for keeping client-side related information (eg: div height, or something like  isModalWarningDisplayed = true ).  Example:  palindrom.obj.myLocalNonSyncedObject.divHeight = 50;  ... does not generate a patch.  Note:  In most cases, the added property is recommended to be an object. *  *Note: You should not replace the value of the non-enumerable property after it has been defined. Otherwise Palindrom will still detect the change. If you want to modify the unobserved values, you should declare the non-enumerable property as an object and only modify its children.",
            "title": "Example:"
        },
        {
            "location": "/03-_Filtering_and_ignoring_changes/#2-by-extending-palindromfilterlocalchange",
            "text": "You can discard a generated patch by extending  Palindrom.filterLocalChange  function. This function accepts a JSON Patch operation and either returns it or returns a falsy value. Returning a falsy value results in ignoring this operation.",
            "title": "2. By extending Palindrom#filterLocalChange"
        },
        {
            "location": "/03-_Filtering_and_ignoring_changes/#example_1",
            "text": "const palindrom = new Palindrom({ remoteUrl: window.location.href });\n\nvar old = palindrom.filterLocalChange;\npalindrom.filterLocalChange = function(operation) {\n    operation = old.call(palindrom, operation); //make sure you don't overwrite other filters\n    if (operation && !operation.path.startsWith('$')) {\n        return operation;\n    }\n}\n// use palindrom.obj\npalindrom.obj.$someProperty = 'new value'; // this change will be ignored and will not reach the server  You can also pass  filterLocalChange  to Palindrom constructor as in:  const palindrom = new Palindrom({ remoteUrl: window.location.href, filterLocalChange: op => !op.path.startsWith('$') && op });",
            "title": "Example"
        },
        {
            "location": "/04-_PalindromDOM/",
            "text": "PalindromDOM\n\n\n\n\nExtension to Palindrom that adds DOM into two-way data binding chain (DOM \u2194 local JSON \u2194 remote JSON). Client side library that binds data on DOM level, so it integrates nicely with good old JavaScript, WebComponents, or Angular.\n\n\n\n\nImplements \nServer communication\n.\n\n\nUsage\n\n\nAfter DOM is ready, initialize with the constructor:\n\n\n/**\n * Defines a connection to a remote PATCH server, gives an object that is persistent between browser and server\n */\nvar palindrom = new PalindromDOM({remoteUrl: window.location.href});\n\n\n\n\n\n\nNote 1: Please make sure you pass the correct PATCH server URL.\n\n\nNote 2: \npalindrom.obj\n is only available after \noptions.onStateReset\n is called.\n\n\n\n\nNow any changes to \npalindrom.obj\n will trigger a HTTP PATCH request. And any received will be applied.\n\n\nDemo\n\n\n\n\nExample with Polymer's Template Binding and Web Components\n\n\nExample with Vue\n\n\nExample with React\n\n\n\n\nOptions (\nPalindromDOM()\n constructor parameters)\n\n\nPalindromDOM accepts the same option attributes as Palindrom, plus the ones listed below. All the parameters are optional.\n\n\nvar palindrom = new PalindromDOM({attribute: value});\n\n\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlistenTo\n\n\nHTMLElement\n\n\ndocument\n\n\nDOM node, that indicates a root of subtree to listen to events.\n\n\n\n\n\n\n\n\nmost of them are accessible also in runtime:\n\n\nProperties\n\n\npalindrom.property\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nelement\n\n\nHTMLElement\n\n\ndocument\n\n\nSee \nlistenTo\n above\n\n\n\n\n\n\nlistening\n\n\nBoolean\n\n\ntrue\n\n\nIs listening on\n\n\n\n\n\n\n\n\nMethods\n\n\npalindrom.method()\n\n\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nunlisten\n\n\nHTMLElement\n\n\nStop listening to DOM events\n\n\n\n\n\n\nlisten\n\n\nHTMLElement\n\n\nStart listening to DOM events\n\n\n\n\n\n\n\n\nBrowser history\n\n\nPalindrom uses the HTML5 history API to update the URL in the browser address bar to reflect the new page. It also listens to a \npopstate\n event so it could ask the server for new JSON-Patch to morph the page back to previous state. Due to lack of native \npushstate\n event you need to either:\n * call \npalindrom.changeState(url)\n after your \nhistory.pushState(url)\n,\n * call \npalindrom.morphUrl(url)\n - that will call \npushState\n and update palindrom's state for you,\n * trigger \npalindrom-redirect-pushstate\n with \n{url: \"/new/url\"}\n on \nwindow\n after your \nhistory.pushState(url)\n,\n * or use \n<palindrom-redirect>\n Custom Element that does it for you.\n\n\nMorph URL with an event\n\n\nSometimes, it's tedious to locate the \nPalindromDOM\n instance in your application using \nquerySelector\n, making it bothersome to call \npalindrom.morphUrl\n. In this case, you can dispatch an event to \npalindrom.listenTo\n element if you set one, or to \ndocument\n if you haven't, and \nPaldinromDOM\n with handle it and morph the URL.\n\n\nExample:\n\n\ndocument.dispatchEvent(new CustomEvent('palindrom-morph-url', {detail: {url: yourURL}}))\n\n\n\n\nOr you can create a helper function:\n\n\nfunction morph(url) {\n  document.dispatchEvent(new CustomEvent('palindrom-morph-url', {detail: {url}}))\n}\n\n// then\nmorph(yourURL);",
            "title": "PalindromDOM"
        },
        {
            "location": "/04-_PalindromDOM/#palindromdom",
            "text": "Extension to Palindrom that adds DOM into two-way data binding chain (DOM \u2194 local JSON \u2194 remote JSON). Client side library that binds data on DOM level, so it integrates nicely with good old JavaScript, WebComponents, or Angular.   Implements  Server communication .",
            "title": "PalindromDOM"
        },
        {
            "location": "/04-_PalindromDOM/#usage",
            "text": "After DOM is ready, initialize with the constructor:  /**\n * Defines a connection to a remote PATCH server, gives an object that is persistent between browser and server\n */\nvar palindrom = new PalindromDOM({remoteUrl: window.location.href});   Note 1: Please make sure you pass the correct PATCH server URL.  Note 2:  palindrom.obj  is only available after  options.onStateReset  is called.   Now any changes to  palindrom.obj  will trigger a HTTP PATCH request. And any received will be applied.",
            "title": "Usage"
        },
        {
            "location": "/04-_PalindromDOM/#demo",
            "text": "Example with Polymer's Template Binding and Web Components  Example with Vue  Example with React",
            "title": "Demo"
        },
        {
            "location": "/04-_PalindromDOM/#options-palindromdom-constructor-parameters",
            "text": "PalindromDOM accepts the same option attributes as Palindrom, plus the ones listed below. All the parameters are optional.  var palindrom = new PalindromDOM({attribute: value});     Attribute  Type  Default  Description      listenTo  HTMLElement  document  DOM node, that indicates a root of subtree to listen to events.     most of them are accessible also in runtime:",
            "title": "Options (PalindromDOM() constructor parameters)"
        },
        {
            "location": "/04-_PalindromDOM/#properties",
            "text": "palindrom.property     Property  Type  Default  Description      element  HTMLElement  document  See  listenTo  above    listening  Boolean  true  Is listening on",
            "title": "Properties"
        },
        {
            "location": "/04-_PalindromDOM/#methods",
            "text": "palindrom.method()     Attribute  Type  Description      unlisten  HTMLElement  Stop listening to DOM events    listen  HTMLElement  Start listening to DOM events",
            "title": "Methods"
        },
        {
            "location": "/04-_PalindromDOM/#browser-history",
            "text": "Palindrom uses the HTML5 history API to update the URL in the browser address bar to reflect the new page. It also listens to a  popstate  event so it could ask the server for new JSON-Patch to morph the page back to previous state. Due to lack of native  pushstate  event you need to either:\n * call  palindrom.changeState(url)  after your  history.pushState(url) ,\n * call  palindrom.morphUrl(url)  - that will call  pushState  and update palindrom's state for you,\n * trigger  palindrom-redirect-pushstate  with  {url: \"/new/url\"}  on  window  after your  history.pushState(url) ,\n * or use  <palindrom-redirect>  Custom Element that does it for you.",
            "title": "Browser history"
        },
        {
            "location": "/04-_PalindromDOM/#morph-url-with-an-event",
            "text": "Sometimes, it's tedious to locate the  PalindromDOM  instance in your application using  querySelector , making it bothersome to call  palindrom.morphUrl . In this case, you can dispatch an event to  palindrom.listenTo  element if you set one, or to  document  if you haven't, and  PaldinromDOM  with handle it and morph the URL.  Example:  document.dispatchEvent(new CustomEvent('palindrom-morph-url', {detail: {url: yourURL}}))  Or you can create a helper function:  function morph(url) {\n  document.dispatchEvent(new CustomEvent('palindrom-morph-url', {detail: {url}}))\n}\n\n// then\nmorph(yourURL);",
            "title": "Morph URL with an event"
        },
        {
            "location": "/05-_Navigation_Interception/",
            "text": "Navigation Interception\n\n\nPalindromDOM gives a regular HTML document the benefits of a single-page application by adding a special optimisation to the internal web links.  \n\n\nRegular links in the current host are cancelled and replaced by a GET \nXMLHttpRequest\n to the same URL with \nAccept: application/json-patch+json\n header. Upon this request, the server modifies the model and responds with a patch that contains the minimum set of changes to navigate to the URL.\n\n\nThe browser navigation (i.e. the back, forward and reload buttons) is preserved by the use of the HTML5 History API.\n\n\nOnly links in the current host without the target attribute or with the target attribute set to \n_self\n are intercepted.\n\n\nHow to disable interception\n\n\nSometimes, you need to disable interception even for links within the application. And as mentioned above, if you set the target attribute to anything else than \n_self\n, the navigation from that anchor will not be intercepted.\n\n\nExample:\n\n\n<a href=\"internalLink.html\" target=\"_top\">Go to internal link</a>\n\n\n\n\n... even if \ninternalLink.html\n is part of your application, PalindromDOM will not intercept the navigation and the browser will issue a full HTTP request to \ninternalLink.html\n.\n\n\nAs the value of the \ntarget\n attribute, you might consider one of the following keywords that have a special meaning in HTML:\n\n\n\n\n_top\n - load the URL into the current browser tab or window\n\n\n_blank\n - load the URL into a new browser tab or window\n\n\n\n\nYou can find more information on the \ntarget\n attribute at \nMDN\n.",
            "title": "Navigation Interception"
        },
        {
            "location": "/05-_Navigation_Interception/#navigation-interception",
            "text": "PalindromDOM gives a regular HTML document the benefits of a single-page application by adding a special optimisation to the internal web links.    Regular links in the current host are cancelled and replaced by a GET  XMLHttpRequest  to the same URL with  Accept: application/json-patch+json  header. Upon this request, the server modifies the model and responds with a patch that contains the minimum set of changes to navigate to the URL.  The browser navigation (i.e. the back, forward and reload buttons) is preserved by the use of the HTML5 History API.  Only links in the current host without the target attribute or with the target attribute set to  _self  are intercepted.",
            "title": "Navigation Interception"
        },
        {
            "location": "/05-_Navigation_Interception/#how-to-disable-interception",
            "text": "Sometimes, you need to disable interception even for links within the application. And as mentioned above, if you set the target attribute to anything else than  _self , the navigation from that anchor will not be intercepted.  Example:  <a href=\"internalLink.html\" target=\"_top\">Go to internal link</a>  ... even if  internalLink.html  is part of your application, PalindromDOM will not intercept the navigation and the browser will issue a full HTTP request to  internalLink.html .  As the value of the  target  attribute, you might consider one of the following keywords that have a special meaning in HTML:   _top  - load the URL into the current browser tab or window  _blank  - load the URL into a new browser tab or window   You can find more information on the  target  attribute at  MDN .",
            "title": "How to disable interception"
        },
        {
            "location": "/06-_Dependencies/",
            "text": "Dependencies\n\n\nIt depends on Native \nES6 Proxies\n. Check usability on \ncaniuse\n.\n\n\nIf you use the bundle, no file dependencies are needed. You can view all the dependencies in \npackage.json\n.",
            "title": "Dependencies"
        },
        {
            "location": "/06-_Dependencies/#dependencies",
            "text": "It depends on Native  ES6 Proxies . Check usability on  caniuse .  If you use the bundle, no file dependencies are needed. You can view all the dependencies in  package.json .",
            "title": "Dependencies"
        },
        {
            "location": "/07-_Numbers/",
            "text": "Numbers\n\n\nPalindrom is a JavaScript library that binds client-side view-models to server side view-models. While Palindrom is a JavaScript library, the server may or may not be built with JavaScript. And this can result in some differences in data types, particularly in numbers. To quote MDN's \nNumber\n page:\n\n\nvar biggestInt = 9007199254740991;\nvar smallestInt = -9007199254740991\n\n\n\n\n\n\nWhen parsing data that has been serialized to JSON, integer values falling out of this range can be expected to become corrupted when JSON parser coerces them to Number type. Using String instead is a possible workaround.\n\n\n\n\nIt is not a limitation of JSON, but of JavaScript, that all numbers are stored in memory as float64 (equivalent to \nDouble\n in C#). This means that numbers larger than +/- \n9007199254740991\n cannot be used in JavaScript without losing precision. \n\n\nNumbers validation\n\n\nTo ensure the validity of your data all the time, Palindrom validates each number it comes across and throws an error when it encounters an out-of-range value, from both endpoints:\n\n\n\n\nFrom Server's endpoint\n: It calls \nonIncomingPatchValidationError\n with a \nRangeError\n with an elaborate message.\n\n\nFrom Client's endpoint\n: It calls \nonOutgoingPatchValidationError\n with a \nRangeError\n with an elaborate message.\n\n\n\n\nFor more information about these callbacks, please refer to Section 2.",
            "title": "Numbers"
        },
        {
            "location": "/07-_Numbers/#numbers",
            "text": "Palindrom is a JavaScript library that binds client-side view-models to server side view-models. While Palindrom is a JavaScript library, the server may or may not be built with JavaScript. And this can result in some differences in data types, particularly in numbers. To quote MDN's  Number  page:  var biggestInt = 9007199254740991;\nvar smallestInt = -9007199254740991   When parsing data that has been serialized to JSON, integer values falling out of this range can be expected to become corrupted when JSON parser coerces them to Number type. Using String instead is a possible workaround.   It is not a limitation of JSON, but of JavaScript, that all numbers are stored in memory as float64 (equivalent to  Double  in C#). This means that numbers larger than +/-  9007199254740991  cannot be used in JavaScript without losing precision.",
            "title": "Numbers"
        },
        {
            "location": "/07-_Numbers/#numbers-validation",
            "text": "To ensure the validity of your data all the time, Palindrom validates each number it comes across and throws an error when it encounters an out-of-range value, from both endpoints:   From Server's endpoint : It calls  onIncomingPatchValidationError  with a  RangeError  with an elaborate message.  From Client's endpoint : It calls  onOutgoingPatchValidationError  with a  RangeError  with an elaborate message.   For more information about these callbacks, please refer to Section 2.",
            "title": "Numbers validation"
        },
        {
            "location": "/08-_Development/",
            "text": "Development\n\n\n\n\nMake a local clone of this repo: \ngit clone git@github.com:Palindrom/Palindrom.git\n\n\nGo to the directory: \ncd Palindrom\n\n\nInstall the local dependencies: \nnpm install\n\n\nStart the development server: \npolyserve -p 8000\n\n\nbundle by calling \nnpm run build\n in your shell.\n\n\nOpen the test suite: \nhttp://localhost:8000/components/Palindrom/test/MochaSpecRunner.html\n\n\n\n\nUpdating documentation\n\n\nEverything in \ndocs\n folder is automatically fetched by the website and each MD file is considered a documentation section. Sections are sorted alphabetically; it's recommended to prefix your file with a numeric ordering index. Eg. (\n01-installation.md\n, \n02-development.md\n..etc).\n\n\nReleases\n\n\nTo release new version run\n\n\nnpm version <patch|minor|major> # to replace version in files and tag the repo\ngit push && git push --tags\n...\nnpm publish\n\n\n\n\n\nTesting\n\n\nYou can test Palindrom using three methods depending on your need (what you've modified):\n\n\n\n\nCLI testing:\n it is perfect for testing Palindrom only (as opposed to testing Palindrom + PalindromDOM). It's the fastest and the easiest to run, all you need to do is run:\n\n\n\n\nnpm run test\n\n\n\n\n\n\n\n\nLocal browser testing:\n This allows you to test (Palindrom + PalindromDOM), you can run it by following steps 4, 5, and 6 from \nDevelopment section\n.\n\n\n\n\n\n\nSauceLabs CLI Testing:\n This runs in the CLI, but it needs SauceLabs credentials, and Selenium needs to be running, to run it:\n\n\n\n\n\n\nInstall \nSauce Connect\n.\n\n\n\n\n\n\nAdd your \nSAUCE_USERNAME\n and \nSAUCE_ACCESS_KEY\n environment variables to your machine.\n\n\n\n\n\n\nConnect to SauceLabs using the command\n \nsc /u YOUR_SAUCE_USER /k YOUR_SAUCE_ACCESSKEY\n where \nsc\n is the executable you get when you download \nSauce Connect\n.\n\n\n\n\n\n\nStart a web server \npolyserve -p 8000\n\n\n\n\n\n\nIn project's root folder, run \nnpm run test-sauce",
            "title": "Development"
        },
        {
            "location": "/08-_Development/#development",
            "text": "Make a local clone of this repo:  git clone git@github.com:Palindrom/Palindrom.git  Go to the directory:  cd Palindrom  Install the local dependencies:  npm install  Start the development server:  polyserve -p 8000  bundle by calling  npm run build  in your shell.  Open the test suite:  http://localhost:8000/components/Palindrom/test/MochaSpecRunner.html",
            "title": "Development"
        },
        {
            "location": "/08-_Development/#updating-documentation",
            "text": "Everything in  docs  folder is automatically fetched by the website and each MD file is considered a documentation section. Sections are sorted alphabetically; it's recommended to prefix your file with a numeric ordering index. Eg. ( 01-installation.md ,  02-development.md ..etc).",
            "title": "Updating documentation"
        },
        {
            "location": "/08-_Development/#releases",
            "text": "To release new version run  npm version <patch|minor|major> # to replace version in files and tag the repo\ngit push && git push --tags\n...\nnpm publish",
            "title": "Releases"
        },
        {
            "location": "/08-_Development/#testing",
            "text": "You can test Palindrom using three methods depending on your need (what you've modified):   CLI testing:  it is perfect for testing Palindrom only (as opposed to testing Palindrom + PalindromDOM). It's the fastest and the easiest to run, all you need to do is run:   npm run test    Local browser testing:  This allows you to test (Palindrom + PalindromDOM), you can run it by following steps 4, 5, and 6 from  Development section .    SauceLabs CLI Testing:  This runs in the CLI, but it needs SauceLabs credentials, and Selenium needs to be running, to run it:    Install  Sauce Connect .    Add your  SAUCE_USERNAME  and  SAUCE_ACCESS_KEY  environment variables to your machine.    Connect to SauceLabs using the command\n  sc /u YOUR_SAUCE_USER /k YOUR_SAUCE_ACCESSKEY  where  sc  is the executable you get when you download  Sauce Connect .    Start a web server  polyserve -p 8000    In project's root folder, run  npm run test-sauce",
            "title": "Testing"
        },
        {
            "location": "/09-_Changelog/",
            "text": "Changelog\n\n\nTo see the list of recent changes, see \nReleases\n.",
            "title": "Changelog"
        },
        {
            "location": "/09-_Changelog/#changelog",
            "text": "To see the list of recent changes, see  Releases .",
            "title": "Changelog"
        }
    ]
}