{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Intro Binds client side view models to server side view models using JSON-Patch and HTTP PATCH/WebSocket.","title":"Intro"},{"location":"#intro","text":"","title":"Intro"},{"location":"#binds-client-side-view-models-to-server-side-view-models-using-json-patch-and-http-patchwebsocket","text":"","title":"Binds client side view models to server side view models using JSON-Patch and HTTP PATCH/WebSocket."},{"location":"01-_Installation/","text":"Installation The library comes in two flavours: Palindrom and PalindromDOM . The difference is explained on the PalindromDOM page . You can install the library using Bower or NPM : Bower: bower install Palindrom --save Then add source to your HTML: <!-- include a bundle with Palindrom global object --> <script src=\"bower_components/Palindrom/dist/palindrom.min.js\"></script> <!-- or, include a bundle with PalindromDOM global object --> <script src=\"bower_components/Palindrom/dist/palindrom-dom.min.js\"></script> See Dependencies page for details about what's in the bundles. NPM: npm install palindrom --save Then you can require it CommonJS or ES6/TS style: // CommonJS // require Palindrom constructor const Palindrom = require('palindrom').Palindrom; // or, require PalindromDOM constructor const PalindromDOM = require('palindrom').PalindromDOM; // ES6/TS // import Palindrom constructor import { Palindrom } from 'palindrom'; // or, import PalindromDOM constructor import { PalindromDOM } from 'palindrom'; GitHub: You can browse the source code on GitHub or download a ZIP archive from there .","title":"Installation"},{"location":"01-_Installation/#installation","text":"The library comes in two flavours: Palindrom and PalindromDOM . The difference is explained on the PalindromDOM page .","title":"Installation"},{"location":"01-_Installation/#you-can-install-the-library-using-bower-or-npm","text":"","title":"You can install the library using Bower or NPM:"},{"location":"01-_Installation/#bower","text":"bower install Palindrom --save Then add source to your HTML: <!-- include a bundle with Palindrom global object --> <script src=\"bower_components/Palindrom/dist/palindrom.min.js\"></script> <!-- or, include a bundle with PalindromDOM global object --> <script src=\"bower_components/Palindrom/dist/palindrom-dom.min.js\"></script> See Dependencies page for details about what's in the bundles.","title":"Bower:"},{"location":"01-_Installation/#npm","text":"npm install palindrom --save Then you can require it CommonJS or ES6/TS style: // CommonJS // require Palindrom constructor const Palindrom = require('palindrom').Palindrom; // or, require PalindromDOM constructor const PalindromDOM = require('palindrom').PalindromDOM; // ES6/TS // import Palindrom constructor import { Palindrom } from 'palindrom'; // or, import PalindromDOM constructor import { PalindromDOM } from 'palindrom';","title":"NPM:"},{"location":"01-_Installation/#github","text":"You can browse the source code on GitHub or download a ZIP archive from there .","title":"GitHub:"},{"location":"02-_Palindrom/","text":"Palindrom Palindrom is a library for two-way data binding between local and remote JSON models. It uses JSON-Patch for data updates and Operational Transformation for versioning and data consistency. It operates via HTTP or WebSocket or both. Usage After DOM is ready, initialize with the constructor: /** * Defines a connection to a remote PATCH server, gives an object that is persistent between browser and server */ var palindrom = new Palindrom({remoteUrl: window.location.href}); // .. // use palindrom.obj palindrom.obj.someProperty = \"new value\"; Note 1: Please make sure you pass the correct PATCH server URL. Note 2: palindrom.obj is only available after options.onStateReset is called. Demo Example with Polymer's Template Binding and Web Components Example with Vue Example with React Options ( Palindrom() constructor argument) All the argument's properties are optional. var palindrom = new Palindrom({property: value}); Property Type Default Description remoteUrl String Required PATCH server URL onStateReset Function Called after initial state object is received from the server (NOT necessarily after WS connection was established), it can be called again if the state was reset by a root-replacing patch . Arguments: Object New state object useWebSocket Boolean false Set to true to enable WebSocket support debug Boolean true Toggle debugging mode filterLocalChange Function A function that is called with every local change and allows you to filter (ignore) some changes. See Filtering Patches section. Arguments: Object Operation to go through the filter onLocalChange Function Helper callback triggered each time a change is observed locally. Arguments: JSONPatch Patch (array of operations) onRemoteChange Function Helper callback triggered each time a change is received from the server and applied. Arguments: JSONPatch Patch (array of operations), Array Validation results onPatchReceived Function Callback triggered each time a JSON-patch is received. Arguments: JSONPatch Patch (array of operations) that was send by remote, String URL from which the change was issued, String HTTP method which resulted in this change ('GET' or 'PATCH') or 'WS' if came as Web Socket message onPatchSent Function Helper callback triggered each time a JSON-patch is sent. Arguments: ( String data Patch (array of operations) serialized to string (optional, i.e. null if method equals GET ), String url , String method ) onSocketStateChanged Function Helper callback triggered when socket state changes. Arguments: number state , String url , String data (optional), number code (optional), String reason (only if code is provided) onError Function Helper callback triggered when a generic error occurs. Arguments: PalindromError Error object that has the following properties: String message . It extends ES6 Error, it has the stack trace with all the information Error class offers. onConnectionError Function Helper callback triggered when socket connection closed, socket connection failed to establish, http requiest failed. Arguments: PalindromConnectionError error ). PalindromConnectionError has the following properties: ( String message , String side <Server\\|Client> , String url , String connectionType ). It extends ES6 Error class, it has the stack trace with all the information Error class offers. onIncomingPatchValidationError Function Helper callback triggered when a wrong patch is received. Arguments: Error Error object onOutgoingPatchValidationError Function Helper callback triggered when a wrong patch is locally issued. Arguments: Error Error object localVersionPath JSONPointer disabled local version path, set it to enable Versioned JSON Patch communication remoteVersionPath JSONPointer disabled remote version path, set it (and localVersionPath ) to enable Versioned JSON Patch communication ot Boolean false true to enable OT (requires localVersionPath and remoteVersionPath ) purity Boolean false true to enable purist mode of OT pingIntervalS Number 0 Palindrom will generate heartbeats every pingIntervalS seconds if no activity is detected. 0 - disable heartbeat retransmissionThreshold Number 3 After server reports this number of messages missing, we start retransmission onReconnectionCountdown Function Triggered when palindrom detected connection problem and reconnection is scheduled. Called every second until countdown reaches 0 (inclusive). Arguments: number milliseconds to scheduled reconnection. onReconnectionEnd Function Triggered when palindrom successfully reconnected. No arguments. jsonpatch Object window.jsonpatch The provider object for jsonpatch apply and validate . By default it uses Starcounter-Jack/JSON-Patch library. most of the properties are accessible also in runtime: Properties palindrom.property Attribute Type Default Description remoteUrl String Required See above obj [readonly] Object {} Your initial state object, please read notes below . useWebSocket Boolean false See above debug Boolean true See above onRemoteChange Function See above onPatchReceived Function See above onSocketStateChanged Function See above onPatchSent Function See above onConnectionError Function See above onIncomingPatchValidationError Function See above onOutgoingPatchValidationError Function See above version String semver Contains current Palindrom version, available statically too (i.e: Palindrom.version ) Note 1: palindrom.obj becomes only available after options.onStateReset is called. Note 2: palindrom.obj is a constant (as in const ) property, you can modify its properties but you can't assign it again or delete it. palindrom.obj = {} would throw an error. Binding object once is ready ( onStateReset ) To bind object where you need once it will be fetched from remote you can use define onStateReset in constructor: var palindrom = new Palindrom({remoteUrl: url, onStateReset: function (obj) { document.getElementById('test').model = obj; }}); Sending client changes to remote Palindrom detects changes to the observed object synchronously. So after palindrom.obj.some=\"change\"; The JSON Patch request will be send to the remote. Two-way data binding frameworks Palindrom works superbly with frameworks that allow for two-way data binding, such as Polymer, React, Vue and Angular. These frameworks have the ability to bind an <input> element to a JavaScript data model in a way that the object updates after each keystroke. In consequence, Palindrom sends a patch the server after each keystroke. If you want to opt-out from such behavior, you need to force your framework to update the data model after the element is unfocused ( blur event). Depending on the framework: In Polymer 0.5 it is only possible with a Custom Element that extends the native <input> , similarly but not exactly how core-input is dome In Polymer 0.9+, use built-in <input value=\"{{bindValue::blur}}\"> In Angular 1.3+, use built-in <input type=\"text\" ng-model=\"name\" ng-model-options=\"{updateOn: 'blur'}\" /> Upgrading to WebSocket ( useWebSocket ) You can upgrade the communication protocol to use WebSocket by setting useWebSocket: true option in Palindrom constructor or you can switch it at any moment by palindrom.useWebSocket = true . WebSocket is a replacement for requests that would be sent using HTTP PATCH otherwise. The requests sent over HTTP GET (such as link clicks) are not affected. :bulb: Note that this is an experimental implementation in which the WebSocket upgrade request URL taken from X-Location header of your first AJAX call response. Sample: // enable it in constructor var palindrom = new Palindrom({remoteUrl: url, useWebSocket: true}); // change it later via property palindrom.useWebSocket = false; Heartbeat and reconnection Palindrom will try to detect connection problems and then reconnect to server. If pingIntervalS is set it determines maximal time without network activity. When this time passes and no activity has been detected Palindrom will issue a heartbeat patch (an empty patch, consisting only of version operations). When connection problem is detected (e.g. there was no response to heartbeat or websocket has been closed) palindrom will schedule reconnection and trigger onReconnectionCountdown callback with number of milliseconds to scheduled reconnection as argument, it will then trigger it every second. When countdown reaches 0 (callback is still called then) palindrom will try to reconnect (using /reconnect endpoint) to server. If this reconnection fails then new reconnection will be scheduled for twice as many seconds (i.e. first it will occur after a seconds, then two seconds, then four, etc.). If reconnection succeeds, onReconnectionEnd callback will be triggered and normal operations will continue. For successful reconnection, palindrom sends a list of pending patches (those sent, but unconfirmed by server) to /reconnect endpoint and accepts a new state (along with version numbers) as a response. It then resets to this new state and resumes its operations.","title":"Palindrom"},{"location":"02-_Palindrom/#palindrom","text":"Palindrom is a library for two-way data binding between local and remote JSON models. It uses JSON-Patch for data updates and Operational Transformation for versioning and data consistency. It operates via HTTP or WebSocket or both.","title":"Palindrom"},{"location":"02-_Palindrom/#usage","text":"After DOM is ready, initialize with the constructor: /** * Defines a connection to a remote PATCH server, gives an object that is persistent between browser and server */ var palindrom = new Palindrom({remoteUrl: window.location.href}); // .. // use palindrom.obj palindrom.obj.someProperty = \"new value\"; Note 1: Please make sure you pass the correct PATCH server URL. Note 2: palindrom.obj is only available after options.onStateReset is called.","title":"Usage"},{"location":"02-_Palindrom/#demo","text":"Example with Polymer's Template Binding and Web Components Example with Vue Example with React","title":"Demo"},{"location":"02-_Palindrom/#options-palindrom-constructor-argument","text":"All the argument's properties are optional. var palindrom = new Palindrom({property: value}); Property Type Default Description remoteUrl String Required PATCH server URL onStateReset Function Called after initial state object is received from the server (NOT necessarily after WS connection was established), it can be called again if the state was reset by a root-replacing patch . Arguments: Object New state object useWebSocket Boolean false Set to true to enable WebSocket support debug Boolean true Toggle debugging mode filterLocalChange Function A function that is called with every local change and allows you to filter (ignore) some changes. See Filtering Patches section. Arguments: Object Operation to go through the filter onLocalChange Function Helper callback triggered each time a change is observed locally. Arguments: JSONPatch Patch (array of operations) onRemoteChange Function Helper callback triggered each time a change is received from the server and applied. Arguments: JSONPatch Patch (array of operations), Array Validation results onPatchReceived Function Callback triggered each time a JSON-patch is received. Arguments: JSONPatch Patch (array of operations) that was send by remote, String URL from which the change was issued, String HTTP method which resulted in this change ('GET' or 'PATCH') or 'WS' if came as Web Socket message onPatchSent Function Helper callback triggered each time a JSON-patch is sent. Arguments: ( String data Patch (array of operations) serialized to string (optional, i.e. null if method equals GET ), String url , String method ) onSocketStateChanged Function Helper callback triggered when socket state changes. Arguments: number state , String url , String data (optional), number code (optional), String reason (only if code is provided) onError Function Helper callback triggered when a generic error occurs. Arguments: PalindromError Error object that has the following properties: String message . It extends ES6 Error, it has the stack trace with all the information Error class offers. onConnectionError Function Helper callback triggered when socket connection closed, socket connection failed to establish, http requiest failed. Arguments: PalindromConnectionError error ). PalindromConnectionError has the following properties: ( String message , String side <Server\\|Client> , String url , String connectionType ). It extends ES6 Error class, it has the stack trace with all the information Error class offers. onIncomingPatchValidationError Function Helper callback triggered when a wrong patch is received. Arguments: Error Error object onOutgoingPatchValidationError Function Helper callback triggered when a wrong patch is locally issued. Arguments: Error Error object localVersionPath JSONPointer disabled local version path, set it to enable Versioned JSON Patch communication remoteVersionPath JSONPointer disabled remote version path, set it (and localVersionPath ) to enable Versioned JSON Patch communication ot Boolean false true to enable OT (requires localVersionPath and remoteVersionPath ) purity Boolean false true to enable purist mode of OT pingIntervalS Number 0 Palindrom will generate heartbeats every pingIntervalS seconds if no activity is detected. 0 - disable heartbeat retransmissionThreshold Number 3 After server reports this number of messages missing, we start retransmission onReconnectionCountdown Function Triggered when palindrom detected connection problem and reconnection is scheduled. Called every second until countdown reaches 0 (inclusive). Arguments: number milliseconds to scheduled reconnection. onReconnectionEnd Function Triggered when palindrom successfully reconnected. No arguments. jsonpatch Object window.jsonpatch The provider object for jsonpatch apply and validate . By default it uses Starcounter-Jack/JSON-Patch library. most of the properties are accessible also in runtime:","title":"Options (Palindrom() constructor argument)"},{"location":"02-_Palindrom/#properties","text":"palindrom.property Attribute Type Default Description remoteUrl String Required See above obj [readonly] Object {} Your initial state object, please read notes below . useWebSocket Boolean false See above debug Boolean true See above onRemoteChange Function See above onPatchReceived Function See above onSocketStateChanged Function See above onPatchSent Function See above onConnectionError Function See above onIncomingPatchValidationError Function See above onOutgoingPatchValidationError Function See above version String semver Contains current Palindrom version, available statically too (i.e: Palindrom.version ) Note 1: palindrom.obj becomes only available after options.onStateReset is called. Note 2: palindrom.obj is a constant (as in const ) property, you can modify its properties but you can't assign it again or delete it. palindrom.obj = {} would throw an error.","title":"Properties"},{"location":"02-_Palindrom/#binding-object-once-is-ready-onstatereset","text":"To bind object where you need once it will be fetched from remote you can use define onStateReset in constructor: var palindrom = new Palindrom({remoteUrl: url, onStateReset: function (obj) { document.getElementById('test').model = obj; }});","title":"Binding object once is ready (onStateReset)"},{"location":"02-_Palindrom/#sending-client-changes-to-remote","text":"Palindrom detects changes to the observed object synchronously. So after palindrom.obj.some=\"change\"; The JSON Patch request will be send to the remote.","title":"Sending client changes to remote"},{"location":"02-_Palindrom/#two-way-data-binding-frameworks","text":"Palindrom works superbly with frameworks that allow for two-way data binding, such as Polymer, React, Vue and Angular. These frameworks have the ability to bind an <input> element to a JavaScript data model in a way that the object updates after each keystroke. In consequence, Palindrom sends a patch the server after each keystroke. If you want to opt-out from such behavior, you need to force your framework to update the data model after the element is unfocused ( blur event). Depending on the framework: In Polymer 0.5 it is only possible with a Custom Element that extends the native <input> , similarly but not exactly how core-input is dome In Polymer 0.9+, use built-in <input value=\"{{bindValue::blur}}\"> In Angular 1.3+, use built-in <input type=\"text\" ng-model=\"name\" ng-model-options=\"{updateOn: 'blur'}\" />","title":"Two-way data binding frameworks"},{"location":"02-_Palindrom/#upgrading-to-websocket-usewebsocket","text":"You can upgrade the communication protocol to use WebSocket by setting useWebSocket: true option in Palindrom constructor or you can switch it at any moment by palindrom.useWebSocket = true . WebSocket is a replacement for requests that would be sent using HTTP PATCH otherwise. The requests sent over HTTP GET (such as link clicks) are not affected. :bulb: Note that this is an experimental implementation in which the WebSocket upgrade request URL taken from X-Location header of your first AJAX call response. Sample: // enable it in constructor var palindrom = new Palindrom({remoteUrl: url, useWebSocket: true}); // change it later via property palindrom.useWebSocket = false;","title":"Upgrading to WebSocket (useWebSocket)"},{"location":"02-_Palindrom/#heartbeat-and-reconnection","text":"Palindrom will try to detect connection problems and then reconnect to server. If pingIntervalS is set it determines maximal time without network activity. When this time passes and no activity has been detected Palindrom will issue a heartbeat patch (an empty patch, consisting only of version operations). When connection problem is detected (e.g. there was no response to heartbeat or websocket has been closed) palindrom will schedule reconnection and trigger onReconnectionCountdown callback with number of milliseconds to scheduled reconnection as argument, it will then trigger it every second. When countdown reaches 0 (callback is still called then) palindrom will try to reconnect (using /reconnect endpoint) to server. If this reconnection fails then new reconnection will be scheduled for twice as many seconds (i.e. first it will occur after a seconds, then two seconds, then four, etc.). If reconnection succeeds, onReconnectionEnd callback will be triggered and normal operations will continue. For successful reconnection, palindrom sends a list of pending patches (those sent, but unconfirmed by server) to /reconnect endpoint and accepts a new state (along with version numbers) as a response. It then resets to this new state and resumes its operations.","title":"Heartbeat and reconnection"},{"location":"03-_Filtering_and_ignoring_changes/","text":"Filtering and ignoring changes Palindrom deeply observes changes made to the palindrom.obj object and converts them to patches. If you have a need to ignore some kind of changes, there are two ways to do it. Either make the changes in non-enumerable property or use a filtering function to ignore changes made in the enumerable properties. 1. By defining non-enumerable properties (recommended) : Palindrom only generates patches for the enumerable properties of palindrom.obj and its subtrees. To create a part of the tree that is invisible for Palindrom's patch collection, define a non-enumerable property. Assuming your Palindrom instance is instantiated and your palindrom.obj is ready, you can create a non-enumerable object child in palindrom.obj and use it as a local non-observed store for your needs. Example: Object.defineProperty(palindrom.obj, \"myLocalNonSyncedObject\", { enumerable: false, value: {} }); Now palindrom.obj.myLocalNonSyncedObject is an object this is not observed for patch generation. This is ideal for keeping client-side related information (eg: div height, or something like isModalWarningDisplayed = true ). Example: palindrom.obj.myLocalNonSyncedObject.divHeight = 50; ... does not generate a patch. Note: In most cases, the added property is recommended to be an object. * *Note: You should not replace the value of the non-enumerable property after it has been defined. Otherwise Palindrom will still detect the change. If you want to modify the unobserved values, you should declare the non-enumerable property as an object and only modify its children. 2. By extending Palindrom#filterLocalChange You can discard a generated patch by extending Palindrom.filterLocalChange function. This function accepts a JSON Patch operation and either returns it or returns a falsy value. Returning a falsy value results in ignoring this operation. Example const palindrom = new Palindrom({ remoteUrl: window.location.href }); var old = palindrom.filterLocalChange; palindrom.filterLocalChange = function(operation) { operation = old.call(palindrom, operation); //make sure you don't overwrite other filters if (operation && !operation.path.startsWith('$')) { return operation; } } // use palindrom.obj palindrom.obj.$someProperty = 'new value'; // this change will be ignored and will not reach the server You can also pass filterLocalChange to Palindrom constructor as in: const palindrom = new Palindrom({ remoteUrl: window.location.href, filterLocalChange: op => !op.path.startsWith('$') && op });","title":"Filtering and ignoring changes"},{"location":"03-_Filtering_and_ignoring_changes/#filtering-and-ignoring-changes","text":"Palindrom deeply observes changes made to the palindrom.obj object and converts them to patches. If you have a need to ignore some kind of changes, there are two ways to do it. Either make the changes in non-enumerable property or use a filtering function to ignore changes made in the enumerable properties.","title":"Filtering and ignoring changes"},{"location":"03-_Filtering_and_ignoring_changes/#1-by-defining-non-enumerable-properties-recommended","text":"Palindrom only generates patches for the enumerable properties of palindrom.obj and its subtrees. To create a part of the tree that is invisible for Palindrom's patch collection, define a non-enumerable property. Assuming your Palindrom instance is instantiated and your palindrom.obj is ready, you can create a non-enumerable object child in palindrom.obj and use it as a local non-observed store for your needs.","title":"1. By defining non-enumerable properties (recommended):"},{"location":"03-_Filtering_and_ignoring_changes/#example","text":"Object.defineProperty(palindrom.obj, \"myLocalNonSyncedObject\", { enumerable: false, value: {} }); Now palindrom.obj.myLocalNonSyncedObject is an object this is not observed for patch generation. This is ideal for keeping client-side related information (eg: div height, or something like isModalWarningDisplayed = true ). Example: palindrom.obj.myLocalNonSyncedObject.divHeight = 50; ... does not generate a patch. Note: In most cases, the added property is recommended to be an object. * *Note: You should not replace the value of the non-enumerable property after it has been defined. Otherwise Palindrom will still detect the change. If you want to modify the unobserved values, you should declare the non-enumerable property as an object and only modify its children.","title":"Example:"},{"location":"03-_Filtering_and_ignoring_changes/#2-by-extending-palindromfilterlocalchange","text":"You can discard a generated patch by extending Palindrom.filterLocalChange function. This function accepts a JSON Patch operation and either returns it or returns a falsy value. Returning a falsy value results in ignoring this operation.","title":"2. By extending Palindrom#filterLocalChange"},{"location":"03-_Filtering_and_ignoring_changes/#example_1","text":"const palindrom = new Palindrom({ remoteUrl: window.location.href }); var old = palindrom.filterLocalChange; palindrom.filterLocalChange = function(operation) { operation = old.call(palindrom, operation); //make sure you don't overwrite other filters if (operation && !operation.path.startsWith('$')) { return operation; } } // use palindrom.obj palindrom.obj.$someProperty = 'new value'; // this change will be ignored and will not reach the server You can also pass filterLocalChange to Palindrom constructor as in: const palindrom = new Palindrom({ remoteUrl: window.location.href, filterLocalChange: op => !op.path.startsWith('$') && op });","title":"Example"},{"location":"04-_PalindromDOM/","text":"PalindromDOM Extension to Palindrom that adds navigation interception. This allows to have links on the HTML page that send and receive patches instead of full page reloads. The navigation appears to be full for the end user, thanks to the use of History API to update the URL in the browser address bar. More details about this feature on the next page: Navigation interception . PalindromDOM is used in scenarios when the Palindrom instance is a client that runs in a Web browser and the HTML document contains links, which should be intercepted and sent to the server as patches. Usage After DOM is ready, initialize the PalindromDOM constructor instead of Palindrom constructor: /** * Defines a connection to a remote PATCH server, gives an object that is persistent between browser and server */ const palindrom = new PalindromDOM({remoteUrl: window.location.href}); Note 1: Please make sure you pass the correct PATCH server URL. Note 2: palindrom.obj is only available after options.onStateReset is called. Now any changes to palindrom.obj will trigger a HTTP PATCH request. And any received will be applied. Demo Example with Polymer's Template Binding and Web Components Example with Vue Example with React Options ( PalindromDOM() constructor parameters) PalindromDOM accepts the same option attributes as Palindrom, plus the ones listed below. All the parameters are optional. var palindrom = new PalindromDOM({attribute: value}); Attribute Type Default Description listenTo HTMLElement document DOM node, that indicates a root of subtree to listen to DOM events. most of them are accessible also in runtime: Properties palindrom.property Property Type Default Description element HTMLElement document The element on which PalindromDOM is listening to DOM events (document or the the element passed using the listenTo option) listening Boolean true True if DOM event listening is on Methods palindrom.method() Attribute Arguments Description unlisten None Stop listening to DOM events listen target: HTMLElement Start listening to DOM events async morphUrl url: String Navigates to a URL by making a request using async getPatchUsingHTTP followed by a History API call. async getPatchUsingHTTP url: String Sends a PATCH/GET request to the server demanding a patch that synchronizes server and client sides. It sends a PATCH request when there are pending data in the client's queue. And a GET request when there is not. Morphing pages programmatically PalindromDOM uses the HTML5 history API to update the URL in the browser address bar to reflect the new page. It also listens to a popstate event so it could ask the server for new JSON-Patch to morph the page back to previous state. To morph to a page programmatically, you need to either: If you don't have a reference to the PalindromDOM instance: trigger palindrom-morph-url or palindrom-redirect-pushstate event with {url: \"/new/url\"} on palindrom.element (equals document by default). This will call morphUrl for you. Example: document.dispatchEvent(new CustomEvent('palindrom-morph-url', {detail: {url: yourURL}})) , or use <palindrom-redirect> Custom Element that does it for you. If you have a reference to the PalindromDOM instance: call palindrom.morphUrl(url) - this will call history.pushState and update PalindromDOM's state for you, call palindrom.getPatchUsingHTTP(url) after your history.pushState(url) . This method returns a Promise<Response> . This methods throws an error if the HTTP request has failed or the palindrom-before-redirect was canceled by calling event.preventDefault() .","title":"PalindromDOM"},{"location":"04-_PalindromDOM/#palindromdom","text":"Extension to Palindrom that adds navigation interception. This allows to have links on the HTML page that send and receive patches instead of full page reloads. The navigation appears to be full for the end user, thanks to the use of History API to update the URL in the browser address bar. More details about this feature on the next page: Navigation interception . PalindromDOM is used in scenarios when the Palindrom instance is a client that runs in a Web browser and the HTML document contains links, which should be intercepted and sent to the server as patches.","title":"PalindromDOM"},{"location":"04-_PalindromDOM/#usage","text":"After DOM is ready, initialize the PalindromDOM constructor instead of Palindrom constructor: /** * Defines a connection to a remote PATCH server, gives an object that is persistent between browser and server */ const palindrom = new PalindromDOM({remoteUrl: window.location.href}); Note 1: Please make sure you pass the correct PATCH server URL. Note 2: palindrom.obj is only available after options.onStateReset is called. Now any changes to palindrom.obj will trigger a HTTP PATCH request. And any received will be applied.","title":"Usage"},{"location":"04-_PalindromDOM/#demo","text":"Example with Polymer's Template Binding and Web Components Example with Vue Example with React","title":"Demo"},{"location":"04-_PalindromDOM/#options-palindromdom-constructor-parameters","text":"PalindromDOM accepts the same option attributes as Palindrom, plus the ones listed below. All the parameters are optional. var palindrom = new PalindromDOM({attribute: value}); Attribute Type Default Description listenTo HTMLElement document DOM node, that indicates a root of subtree to listen to DOM events. most of them are accessible also in runtime:","title":"Options (PalindromDOM() constructor parameters)"},{"location":"04-_PalindromDOM/#properties","text":"palindrom.property Property Type Default Description element HTMLElement document The element on which PalindromDOM is listening to DOM events (document or the the element passed using the listenTo option) listening Boolean true True if DOM event listening is on","title":"Properties"},{"location":"04-_PalindromDOM/#methods","text":"palindrom.method() Attribute Arguments Description unlisten None Stop listening to DOM events listen target: HTMLElement Start listening to DOM events async morphUrl url: String Navigates to a URL by making a request using async getPatchUsingHTTP followed by a History API call. async getPatchUsingHTTP url: String Sends a PATCH/GET request to the server demanding a patch that synchronizes server and client sides. It sends a PATCH request when there are pending data in the client's queue. And a GET request when there is not.","title":"Methods"},{"location":"04-_PalindromDOM/#morphing-pages-programmatically","text":"PalindromDOM uses the HTML5 history API to update the URL in the browser address bar to reflect the new page. It also listens to a popstate event so it could ask the server for new JSON-Patch to morph the page back to previous state. To morph to a page programmatically, you need to either: If you don't have a reference to the PalindromDOM instance: trigger palindrom-morph-url or palindrom-redirect-pushstate event with {url: \"/new/url\"} on palindrom.element (equals document by default). This will call morphUrl for you. Example: document.dispatchEvent(new CustomEvent('palindrom-morph-url', {detail: {url: yourURL}})) , or use <palindrom-redirect> Custom Element that does it for you. If you have a reference to the PalindromDOM instance: call palindrom.morphUrl(url) - this will call history.pushState and update PalindromDOM's state for you, call palindrom.getPatchUsingHTTP(url) after your history.pushState(url) . This method returns a Promise<Response> . This methods throws an error if the HTTP request has failed or the palindrom-before-redirect was canceled by calling event.preventDefault() .","title":"Morphing pages programmatically"},{"location":"05-_Navigation_Interception/","text":"Navigation Interception PalindromDOM gives a regular HTML document the benefits of a single-page application by adding a special optimisation to the internal web links. Regular links in the current host are cancelled and replaced by a GET XMLHttpRequest to the same URL with Accept: application/json-patch+json header. Upon this request, the server modifies the model and responds with a patch that contains the minimum set of changes to navigate to the URL. The browser navigation (i.e. the back, forward and reload buttons) is preserved by the use of the HTML5 History API. Only links in the current host without the target attribute or with the target attribute set to _self are intercepted. How to disable interception for an HTML link Sometimes, you need to disable interception even for links within the application. And as mentioned above, if you set the target attribute to anything else than _self , the navigation from that anchor will not be intercepted. Example: <a href=\"internalLink.html\" target=\"_top\">Go to internal link</a> ... even if internalLink.html is part of your application, PalindromDOM will not intercept the navigation and the browser will issue a full HTTP request to internalLink.html . As the value of the target attribute, you might consider one of the following keywords that have a special meaning in HTML: _top - load the URL into the current browser tab or window _blank - load the URL into a new browser tab or window You can find more information on the target attribute at MDN . Cancellable events before and after navigation Before and after morphing the page upon navigation within your app, PalindromDOM dispatches bubbling navigation events, palindrom-before-redirect and palindrom-after-redirect . You can use these events to watch or even cancel navigation. The palindrom-before-redirect cancellable event is dispatched before the navigation occurs, with detail object containing href: String property that contains the URL. To cancel PalindromDOM navigation, you can cancel palindrom-before-redirect event by calling event.preventDefault() inside your event handler. Then, after you show your confirmation box or whatever purpose you cancelled the navigation for, you can continue the navigation by calling palindrom.morphUrl to the same URL. To record the navigation URL, you can get it from event.detail.href of palindrom-before-redirect event. The palindrom-after-redirect event is dispatched after the navigation occurs, with detail object containing href: String property that contains the URL and data: Object containing the JSON response. Note A programmatic call to palindrom.morphUrl also triggers the navigation events listed above. To distinguish between the events caused by a user interaction and a call to palindrom.morphUrl , you may use a local variable. Example let handledNavigation = false; document.addEventListener('palindrom-before-redirect', event => { if (!handledNavigation) { if (confirm('Are you sure you want to leave this page?')) { // to prevent futher blockage handledNavigation = true; palindrom.morphUrl(event.detail.href); } else { // to show the dialog when navigation happens again handledNavigation = false; } } }); PalindromDOM only triggers the events palindrom-before-redirect and palindrom-after-redirect for the intercepted links. For non-intercepted links, you may use the native beforeunload event.","title":"Navigation Interception"},{"location":"05-_Navigation_Interception/#navigation-interception","text":"PalindromDOM gives a regular HTML document the benefits of a single-page application by adding a special optimisation to the internal web links. Regular links in the current host are cancelled and replaced by a GET XMLHttpRequest to the same URL with Accept: application/json-patch+json header. Upon this request, the server modifies the model and responds with a patch that contains the minimum set of changes to navigate to the URL. The browser navigation (i.e. the back, forward and reload buttons) is preserved by the use of the HTML5 History API. Only links in the current host without the target attribute or with the target attribute set to _self are intercepted.","title":"Navigation Interception"},{"location":"05-_Navigation_Interception/#how-to-disable-interception-for-an-html-link","text":"Sometimes, you need to disable interception even for links within the application. And as mentioned above, if you set the target attribute to anything else than _self , the navigation from that anchor will not be intercepted. Example: <a href=\"internalLink.html\" target=\"_top\">Go to internal link</a> ... even if internalLink.html is part of your application, PalindromDOM will not intercept the navigation and the browser will issue a full HTTP request to internalLink.html . As the value of the target attribute, you might consider one of the following keywords that have a special meaning in HTML: _top - load the URL into the current browser tab or window _blank - load the URL into a new browser tab or window You can find more information on the target attribute at MDN .","title":"How to disable interception for an HTML link"},{"location":"05-_Navigation_Interception/#cancellable-events-before-and-after-navigation","text":"Before and after morphing the page upon navigation within your app, PalindromDOM dispatches bubbling navigation events, palindrom-before-redirect and palindrom-after-redirect . You can use these events to watch or even cancel navigation. The palindrom-before-redirect cancellable event is dispatched before the navigation occurs, with detail object containing href: String property that contains the URL. To cancel PalindromDOM navigation, you can cancel palindrom-before-redirect event by calling event.preventDefault() inside your event handler. Then, after you show your confirmation box or whatever purpose you cancelled the navigation for, you can continue the navigation by calling palindrom.morphUrl to the same URL. To record the navigation URL, you can get it from event.detail.href of palindrom-before-redirect event. The palindrom-after-redirect event is dispatched after the navigation occurs, with detail object containing href: String property that contains the URL and data: Object containing the JSON response.","title":"Cancellable events before and after navigation"},{"location":"05-_Navigation_Interception/#note","text":"A programmatic call to palindrom.morphUrl also triggers the navigation events listed above. To distinguish between the events caused by a user interaction and a call to palindrom.morphUrl , you may use a local variable.","title":"Note"},{"location":"05-_Navigation_Interception/#example","text":"let handledNavigation = false; document.addEventListener('palindrom-before-redirect', event => { if (!handledNavigation) { if (confirm('Are you sure you want to leave this page?')) { // to prevent futher blockage handledNavigation = true; palindrom.morphUrl(event.detail.href); } else { // to show the dialog when navigation happens again handledNavigation = false; } } }); PalindromDOM only triggers the events palindrom-before-redirect and palindrom-after-redirect for the intercepted links. For non-intercepted links, you may use the native beforeunload event.","title":"Example"},{"location":"06-_Dependencies/","text":"Dependencies Palindrom depends on native ES6 Proxy . Check availability of this API on caniuse . If you use the bundle, no file dependencies are needed. You can view all the dependencies in package.json .","title":"Dependencies"},{"location":"06-_Dependencies/#dependencies","text":"Palindrom depends on native ES6 Proxy . Check availability of this API on caniuse . If you use the bundle, no file dependencies are needed. You can view all the dependencies in package.json .","title":"Dependencies"},{"location":"07-_Numbers/","text":"Numbers Palindrom is a JavaScript library that binds client-side view-models to server side view-models. While Palindrom is a JavaScript library, the server may or may not be built with JavaScript. And this can result in some differences in data types, particularly in numbers. To quote MDN's Number page: var biggestInt = 9007199254740991; var smallestInt = -9007199254740991 When parsing data that has been serialized to JSON, integer values falling out of this range can be expected to become corrupted when JSON parser coerces them to Number type. Using String instead is a possible workaround. It is not a limitation of JSON, but of JavaScript, that all numbers are stored in memory as float64 (equivalent to Double in C#). This means that numbers larger than +/- 9007199254740991 cannot be used in JavaScript without losing precision. Numbers validation To ensure the validity of your data all the time, Palindrom validates each number it comes across and throws an error when it encounters an out-of-range value, from both endpoints: From Server's endpoint : It calls onIncomingPatchValidationError with a RangeError with an elaborate message. From Client's endpoint : It calls onOutgoingPatchValidationError with a RangeError with an elaborate message. For more information about these callbacks, please refer to Section 2.","title":"Numbers"},{"location":"07-_Numbers/#numbers","text":"Palindrom is a JavaScript library that binds client-side view-models to server side view-models. While Palindrom is a JavaScript library, the server may or may not be built with JavaScript. And this can result in some differences in data types, particularly in numbers. To quote MDN's Number page: var biggestInt = 9007199254740991; var smallestInt = -9007199254740991 When parsing data that has been serialized to JSON, integer values falling out of this range can be expected to become corrupted when JSON parser coerces them to Number type. Using String instead is a possible workaround. It is not a limitation of JSON, but of JavaScript, that all numbers are stored in memory as float64 (equivalent to Double in C#). This means that numbers larger than +/- 9007199254740991 cannot be used in JavaScript without losing precision.","title":"Numbers"},{"location":"07-_Numbers/#numbers-validation","text":"To ensure the validity of your data all the time, Palindrom validates each number it comes across and throws an error when it encounters an out-of-range value, from both endpoints: From Server's endpoint : It calls onIncomingPatchValidationError with a RangeError with an elaborate message. From Client's endpoint : It calls onOutgoingPatchValidationError with a RangeError with an elaborate message. For more information about these callbacks, please refer to Section 2.","title":"Numbers validation"},{"location":"08-_Development/","text":"Development Make a local clone of this repo: git clone git@github.com:Palindrom/Palindrom.git Go to the directory: cd Palindrom Install the local dependencies: npm install Start the development server: npm run serve Bundle by calling npm run build in your shell, or npm run build-watch to automatically rebuild after every file change Open the test suite: http://localhost:5000/test/MochaSpecRunner.html Updating documentation Everything in docs folder is automatically fetched by the website and each MD file is considered a documentation section. Sections are sorted alphabetically; it's recommended to prefix your file with a numeric ordering index. Eg. ( 01-installation.md , 02-development.md ..etc). Releases To release new version run npm version <patch|minor|major> # to replace version in files and tag the repo git push && git push --tags ... npm publish Testing You can test Palindrom using three methods depending on your need (what you've modified): CLI testing: it is perfect for testing Palindrom only (as opposed to testing Palindrom + PalindromDOM). It's the fastest and the easiest to run, all you need to do is run: npm run test-node Local browser testing: This allows you to test (Palindrom + PalindromDOM), you can run it by following steps 4, 5, and 6 from Development section . SauceLabs CLI Testing: This runs in the CLI, but it needs SauceLabs credentials, and Selenium needs to be running, to run it: Install Sauce Connect . Add your SAUCE_USERNAME and SAUCE_ACCESS_KEY environment variables to your machine. Connect to SauceLabs using the command sc /u %SAUCE_USERNAME% /k %SAUCE_ACCESS_KEY% where sc is the executable you get when you download Sauce Connect . Start a web server npm run serve In project's root folder, run npm run test-sauce To run all CLI tests together, run: npm run test","title":"Development"},{"location":"08-_Development/#development","text":"Make a local clone of this repo: git clone git@github.com:Palindrom/Palindrom.git Go to the directory: cd Palindrom Install the local dependencies: npm install Start the development server: npm run serve Bundle by calling npm run build in your shell, or npm run build-watch to automatically rebuild after every file change Open the test suite: http://localhost:5000/test/MochaSpecRunner.html","title":"Development"},{"location":"08-_Development/#updating-documentation","text":"Everything in docs folder is automatically fetched by the website and each MD file is considered a documentation section. Sections are sorted alphabetically; it's recommended to prefix your file with a numeric ordering index. Eg. ( 01-installation.md , 02-development.md ..etc).","title":"Updating documentation"},{"location":"08-_Development/#releases","text":"To release new version run npm version <patch|minor|major> # to replace version in files and tag the repo git push && git push --tags ... npm publish","title":"Releases"},{"location":"08-_Development/#testing","text":"You can test Palindrom using three methods depending on your need (what you've modified): CLI testing: it is perfect for testing Palindrom only (as opposed to testing Palindrom + PalindromDOM). It's the fastest and the easiest to run, all you need to do is run: npm run test-node Local browser testing: This allows you to test (Palindrom + PalindromDOM), you can run it by following steps 4, 5, and 6 from Development section . SauceLabs CLI Testing: This runs in the CLI, but it needs SauceLabs credentials, and Selenium needs to be running, to run it: Install Sauce Connect . Add your SAUCE_USERNAME and SAUCE_ACCESS_KEY environment variables to your machine. Connect to SauceLabs using the command sc /u %SAUCE_USERNAME% /k %SAUCE_ACCESS_KEY% where sc is the executable you get when you download Sauce Connect . Start a web server npm run serve In project's root folder, run npm run test-sauce To run all CLI tests together, run: npm run test","title":"Testing"},{"location":"09-_Changelog/","text":"Changelog To see the list of recent changes, see Releases .","title":"Changelog"},{"location":"09-_Changelog/#changelog","text":"To see the list of recent changes, see Releases .","title":"Changelog"}]}